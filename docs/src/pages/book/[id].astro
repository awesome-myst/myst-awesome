---
import DocsLayout from '@awesome-myst/myst-awesome/layouts/DocsLayout.astro';
import NavigationMenu from '@awesome-myst/myst-awesome/components/NavigationMenu.astro';
import { getCollection } from 'astro:content';
import type { CollectionEntry } from 'astro:content';

export async function getStaticPaths() {
  // Get all page entries from the pages collection
  const pages = await getCollection('pages');

  return pages
    .filter((page) => page.id && page.id !== '/' && page.id.startsWith('/'))
    .map((page) => ({
      params: { id: page.id.slice(1) }, // Remove leading slash for URL params
      props: { page },
    }));
}

interface PageProps {
  page: CollectionEntry<'pages'>;
}

const { page } = Astro.props as PageProps;

// Fetch all collections
const allPages = await getCollection('pages');
const projectConfig = (await getCollection('projectFrontmatter'))[0];
// console.log('Project pages template config:', projectConfig);

// console.log('Page data:', page.data);

// Extract metadata
const title = page.data.frontmatter?.title ||
              page.data.url ||
              'MyST Page';

const description = page.data.frontmatter?.description ||
                   page.data.description ||
                   projectConfig?.data.project?.description ||
                   'A MyST Markdown page';

// Create navigation items from all pages
const navItems = allPages
  .filter(p => p.id)
  .map(p => ({
    title: p.id === '/' ? 'Home' :
           (p.id.slice(1).charAt(0).toUpperCase() + p.id.slice(2)) || 'Page',
    href: p.id === '/' ? '/' : `/book/${p.id.slice(1)}`,
    current: p.id === page.id,
    icon: p.id === '/' ? 'home' : 'file-text'
  }));

// Extract table of contents from MyST content
const tocItems: Array<{level: number, title: string, href: string, id: string}> = [];

if (page.data.mdast) {
  // Simple extraction of headings from the MyST AST
  const extractHeadings = (node: any): void => {
    if (node.type === 'heading' && node.depth && node.depth <= 4) {
      const text = node.children?.map((child: any) => child.value || '').join('') || '';
      if (text) {
        const id = text.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/^-|-$/g, '');
        tocItems.push({
          level: node.depth,
          title: text,
          href: `#${id}`,
          id: id
        });
      }
    }
    if (node.children) {
      node.children.forEach(extractHeadings);
    }
  };

  if (page.data.mdast.children) {
    page.data.mdast.children.forEach(extractHeadings);
  }
}

// Function to render MyST content as HTML (simplified)
function renderMystContent(content: any): string {
  if (!content?.mdast) {
    return '<p>No content available</p>';
  }

  // This is a simplified renderer - in a real implementation you'd want
  // to use a proper MyST-to-HTML renderer
  const renderNode = (node: any): string => {
    switch (node.type) {
      case 'paragraph':
        return `<p>${node.children?.map(renderNode).join('') || ''}</p>`;
      case 'heading':
        const level = Math.min(6, Math.max(1, node.depth || 2));
        const text = node.children?.map(renderNode).join('') || '';
        const id = text.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/^-|-$/g, '');
        return `<h${level} id="${id}">${text}</h${level}>`;
      case 'text':
        return node.value || '';
      case 'emphasis':
        return `<em>${node.children?.map(renderNode).join('') || ''}</em>`;
      case 'strong':
        return `<strong>${node.children?.map(renderNode).join('') || ''}</strong>`;
      case 'inlineCode':
        return `<code>${node.value || ''}</code>`;
      case 'code':
        return `<pre><code class="language-${node.lang || ''}">${node.value || ''}</code></pre>`;
      case 'list':
        const tag = node.ordered ? 'ol' : 'ul';
        return `<${tag}>${node.children?.map(renderNode).join('') || ''}</${tag}>`;
      case 'listItem':
        return `<li>${node.children?.map(renderNode).join('') || ''}</li>`;
      case 'blockquote':
        return `<blockquote>${node.children?.map(renderNode).join('') || ''}</blockquote>`;
      case 'link':
        return `<a href="${node.url || '#'}">${node.children?.map(renderNode).join('') || ''}</a>`;
      default:
        return node.children?.map(renderNode).join('') || '';
    }
  };

  return content.mdast.children?.map(renderNode).join('\n') || '';
}

// Get prev/next pages for navigation
const currentIndex = allPages.findIndex(p => p.id === page.id);
const prevPage = currentIndex > 0 ? allPages[currentIndex - 1] : null;
const nextPage = currentIndex < allPages.length - 1 ? allPages[currentIndex + 1] : null;
---

<DocsLayout
  title={title}
  description={description}
  section="Book"
  baseDir="/book"
  tocItems={tocItems}
  showBreadcrumbs={true}
  showEditButton={true}
  editUrl={`${projectConfig?.data.project?.github || ''}/edit/main/docs/${page.data?.url === '/' ? 'index' : (page.data?.url || '').slice(1)}.md`}
  author={projectConfig?.data.project?.authors?.[0] || 'MyST Team'}
  lastModified={new Date()}
  nextPage={nextPage && nextPage.id ? {
    title: nextPage.id === '/' ? 'Home' : nextPage.id.slice(1),
    href: nextPage.id === '/' ? '/' : `/book/${nextPage.id.slice(1)}`
  } : undefined}
  prevPage={prevPage && prevPage.id ? {
    title: prevPage.id === '/' ? 'Home' : prevPage.id.slice(1),
    href: prevPage.id === '/' ? '/' : `/book/${prevPage.id.slice(1)}`
  } : undefined}
  showThemeSelector={true}
>
  <!-- Navigation Menu -->
  <NavigationMenu
    slot="navigation"
    items={navItems}
    showSearch={true}
    searchPlaceholder="Search documentation..."
    collapsible={true}
    showIcons={true}
  />

  <!-- Main Content -->
  {page.data ? (
    <article class="myst-content">
      {/* <!-- Page header with metadata -->
      <header class="page-header">
        <h1>{title}</h1>
        {description && description !== title && (
          <p class="page-description">{description}</p>
        )}

        <div class="page-meta">
          <div class="meta-item">
            <wa-icon name="link" variant="solid"></wa-icon>
            <span>URL: {page.data.url}</span>
          </div>
          {page.data.identifier && (
            <div class="meta-item">
              <wa-icon name="hash" variant="solid"></wa-icon>
              <span>ID: {page.data.identifier}</span>
            </div>
          )}
        </div>
      </header> */}

      <!-- Render MyST content -->
      <div class="content-body" set:html={renderMystContent(page.data)} />

      <!-- Show frontmatter if available -->
      {page.data.frontmatter && Object.keys(page.data.frontmatter).length > 0 && (
        <details class="frontmatter-details">
          <summary>
            <wa-icon name="info-circle" variant="solid"></wa-icon>
            Page Frontmatter
          </summary>
          <pre class="frontmatter-code">{JSON.stringify(page.data.frontmatter, null, 2)}</pre>
        </details>
      )}
    </article>
  ) : (
    <div class="loading-container">
      <wa-spinner size="large"></wa-spinner>
      <p>Loading page content...</p>
    </div>
  )}
</DocsLayout>

<script>
  // Import Web Awesome components for client-side hydration
  import '@awesome.me/webawesome/dist/components/callout/callout.js';
  import '@awesome.me/webawesome/dist/components/spinner/spinner.js';
</script>

<style>
  .error-container,
  .loading-container {
    padding: 2rem;
    text-align: center;
    margin: 2rem 0;
  }

  .page-header {
    margin-bottom: 2rem;
    padding-bottom: 1rem;
    border-bottom: 1px solid var(--wa-color-neutral-200);
  }

  .page-description {
    font-size: 1.125rem;
    color: var(--wa-color-neutral-600);
    margin: 0.5rem 0 1rem;
  }

  .page-meta {
    display: flex;
    gap: 1rem;
    flex-wrap: wrap;
    margin-top: 1rem;
  }

  .meta-item {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    font-size: 0.875rem;
    color: var(--wa-color-neutral-600);
  }

  .content-body {
    line-height: 1.7;
    font-size: 1rem;
  }

  .content-body h1,
  .content-body h2,
  .content-body h3,
  .content-body h4,
  .content-body h5,
  .content-body h6 {
    margin-top: 2rem;
    margin-bottom: 1rem;
    line-height: 1.3;
  }

  .content-body h1 { font-size: 2rem; }
  .content-body h2 { font-size: 1.5rem; }
  .content-body h3 { font-size: 1.25rem; }
  .content-body h4 { font-size: 1.125rem; }

  .content-body p {
    margin: 1rem 0;
  }

  .content-body pre {
    background: var(--wa-color-neutral-100);
    padding: 1rem;
    border-radius: var(--wa-border-radius-medium);
    overflow-x: auto;
    font-size: 0.875rem;
    line-height: 1.5;
    margin: 1rem 0;
  }

  .content-body code {
    background: var(--wa-color-neutral-100);
    padding: 0.2rem 0.4rem;
    border-radius: var(--wa-border-radius-small);
    font-size: 0.875rem;
  }

  .content-body blockquote {
    border-left: 4px solid var(--wa-color-primary-200);
    padding-left: 1rem;
    margin: 1rem 0;
    font-style: italic;
    color: var(--wa-color-neutral-600);
  }

  .frontmatter-details {
    margin-top: 2rem;
    border: 1px solid var(--wa-color-neutral-200);
    border-radius: var(--wa-border-radius-medium);
    overflow: hidden;
  }

  .frontmatter-details summary {
    padding: 1rem;
    background: var(--wa-color-neutral-50);
    cursor: pointer;
    display: flex;
    align-items: center;
    gap: 0.5rem;
    font-weight: 500;
  }

  .frontmatter-code {
    padding: 1rem;
    margin: 0;
    background: var(--wa-color-neutral-100);
    font-size: 0.875rem;
    line-height: 1.5;
    overflow-x: auto;
  }

  /* Docs-only mobile behavior: hide TOC and aside at <=920px to prevent empty space */
  @media (max-width: 920px) {
    :global(.responsive-toc-wrapper) {
      display: none !important;
    }
    :global(.page-body.collapse-aside-920 .page-aside) {
      display: none !important;
    }
  }
</style>
